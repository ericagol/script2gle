#!/usr/bin/env python
# coding=utf-8
#
# GENERAL MODULES
from sys import argv
from subprocess import check_call
from re import search, sub, match
from os import remove, listdir, rename
from os.path import splitext, join
from numpy import floor
from time import time
# OWN MODULES
import glec
import s2gf
import s2gd
import s2gc
import s2gap

###########################
# USER ARGUMENTS ##########
###########################
devmode    = False # else-> cleanup temp folders
no_gleplot = False # does not compile GLE files
no_octave  = False # uses matlab instead of octave
no_tex     = True  # for quick graph 
png_out    = False # output in png instead of pdf
png_resol  = ''
if len(argv)>2:
	for arg in argv[2:]:
		if   bool(match(r'-dev',arg)):
			devmode = True
		elif bool(match(r'-noplot|-nogle',arg)):
			no_gleplot = True
		elif bool(match(r'-nooct|-noct',arg)):
			no_octave = True
		elif bool(match(r'-png',arg)):
			png_out   = True
			png_resol = '300'
		elif bool(match(r'-tex',arg)):
			no_tex = False
		else:
			print 'Ignoring unrecognized arg.: <'+arg+'>'
#
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
#
rname  	   = argv[1]
fname,fext = splitext(rname)    # full name with directory + file extension
fext 	   = fext.lower() 		
fname2 	   = fname.split('/')
fname2 	   = fname2[-1] 		# only name of file
gname  	   = fname+'.gle'
s_tmp      = '%s%s_script_tmp'%(s2gd.tind,fname)
s2gd.sname = fname2
figlist    = []
#
# def of the appropriate script dictionary
if fext   == '.jl':
	s2gd.csd = s2gd.script_dict_JL
elif fext == '.r':
	s2gd.csd = s2gd.script_dict_R
elif fext == '.m':
	s2gd.csd = s2gd.script_dict_M	
	if no_octave:
		s2gd.csd['caller'] = 'matlab -nodesktop -nosplash -noFigureWindows -r'
#
s2gd.ignored+= r'|^\s*%s'%s2gd.csd['comment']
s2gd.markers = r'|'.join([s2gd.markers,s2gd.csd['append']])
#
# TEMP TEMP TEMP
markers_dict = {
	'figure' 		: s2gap.parse_figure,
#	'plot'	 		: s2gap.parse_plot,
	'fill'	 		: s2gap.parse_fill,
	'fillbetween'	: s2gap.parse_fillbetween,	# extra syntax
	'hist'			: s2gap.parse_histogram,
	'histogram'		: s2gap.parse_histogram,
#	'bar'			: s2gap.parse_bar,
	'hold'			: s2gap.parse_hold,
#	r'[xy]lim'		: s2gap.parse_xylim,
#	r'[xy]label'	: s2gap.parse_xylabel,
#	'title'			: s2gap.parse_title,
#	r'[xy]?axis'	: s2gap.parse_xyaxis,
#	'set'			: s2gap.parse_set,
#	'legend'		: s2gap.parse_legend,
#	r'semilog[xy]'	: s2gap.parse_semilog,
#	'loglog'		: s2gap.parse_loglog,
#	'stem'			: s2gap.parse_stem,
#	r'(#s2g:)'		: s2gap.parse_s2g,
	}
def donothing(cf,l,**xa):
	return 0,l
# TEMP TEMP TEMP
#
# == MAIN BLOCK =================
# create temp matlab file which
# outputs data file for each plot
with open(rname,'r') as sf_orig: 
	with open(s_tmp+fext,'w+') as sf_tmp:
		#
		# script lines > stack of lines to process
		script_stack = sf_orig.readlines()
		# setup a fig
		curfig 		 = s2gc.S2GFIG(1,no_tex)
		#
		while script_stack:
			#
			# sanitize by gathering multiline expressions (continuation line with '...')
			l,script_stack = s2gf.close_ellipsis(script_stack.pop(0),script_stack)
			#
			# ignore lines starting with (comment symbol, 'home','clear', ...)
			if s2gf.match_start(s2gd.ignored,l): 
				continue
			#
			# get marker if any ('figure','plot',...)
			marker = s2gf.match_start(s2gd.markers, l)
			if not marker:
				sf_tmp.write(l)
				continue
			else:
				marker = marker.group(1)
			#
			# PARSE LINE AFTER MARKER (call appropriate s2gap function)
			cf,l = markers_dict.setdefault(marker,donothing)(curfig,l,figlist=figlist,no_tex=no_tex,script=sf_tmp)
			if cf:
				curfig = cf

			# ---------
			# PLOT LINE
			if match(r'(?:plot|semilog[xy]|stem|loglog|fill|fillbetween|hist|histogram|bar)$',marker):
				#
				# if holding, add plot to current fig
				if curfig.flags['holdon'] or not curfig.plotcntr:
					curfig.plotcntr += 1
				#
				# otherwise create new fig
				else:
					figlist.append(curfig)
					curfig = s2gc.S2GFIG(curfig.fignum+1,no_tex)
				# ------------------
				# <- PLOT ACTIONS ->
				if marker in ['plot','semilogx','semilogy','stem','loglog']:
					# structify: extract code and options
					plt = s2gf.read_plot(l,curfig.fignum,curfig.plotcntr)
					# -> write to temp script file
					sf_tmp.write(plt['script'])
					# -> write to temp gle file
					block = 'data "%sdatplot%i_%i.dat" d%i\n'%(s2gd.tind,curfig.fignum,curfig.plotcntr,curfig.plotcntr)
					block+= 'd%i'%curfig.plotcntr+									\
								' impulses '*bool(match(r'stem',marker))+ 	\
								plt['lstyle']+								\
								plt['lwidth']+								\
								plt['msize']+'\n'
					curfig.plot += block
					curfig.lstyles.append(plt['lstyle'])
					if match(r'semilog[xy]?',marker): curfig.axopt+=marker[-1]+'axis log\n'
					elif match(r'loglog',marker): 	  curfig.axopt+='xaxis log\nyaxis log\n'
				elif marker == 'bar':
					bar = s2gf.read_bar(l,curfig.fignum,curfig.plotcntr)
					# -> write to temp script file
					sf_tmp.write(bar['script'])
					# -> write to temp gle file
					# --- xtra
					block  = 'data "%sdatbar%i_%i_side.dat"\n'%(s2gd.tind,curfig.fignum,curfig.plotcntr,curfig.plotcntr)
					block += 'ncols_ = datayvalue(d%i,1)\n'%(curfig.plotcntr)
					block += 'bstr_$ = "d%i"\n'%(curfig.plotcntr+1)
					block += 'for k=1 to ncols_-1, bstr_$=bstr_$+",d"+num$(k),next k\n'
					# # ---
					# block  = 'data "%sdatbar%i_%i.dat" bstr_$ \n'%(s2gd.tind,curfig.fignum,curfig.plotcntr)
					# block += 'bar d%i color %s fill %s width %f\n'%(curfig.plotcntr+1,bar['edgecolor'],bar['facecolor'],bar['width'])
					#
					xaxisopt  = ''
					if not bar['flticks']:
						xaxisopt+='nofirst nolast '
					if bar['xdticks']:
						xaxisopt+='dticks %s '%bar['xdticks']
					#
					if xaxisopt:
						block += 'xaxis '+xaxisopt+'\n'
					#
					curfig.plot  += block
					curfig.trsp   = curfig.trsp or bar['alpha']
					curfig.plotcntr     += 1
 			# -------------------------
 			# AXIS LINES (pass in temp)
 			# (atm, ignore fontsize)
 			elif match(r'(?:[xy]label|title)$',marker):
 				al = s2gf.getarg1(l)
 				marker = '' if (marker=='title') else marker[0]
 				if no_tex:
 					curfig.axopt+=marker+'title "%s"\n'%sub(r'\\','/',al)
 				else:
 					curfig.axopt+=marker+'title "\\tex{%s}"\n'%sub('%','\%',al)
			elif match(r'(?:[xy]lim)$',marker):
 				al  = s2gf.getarg1(l)
 				al_ = s2gf.array_x(al)
 				curfig.axopt+='%saxis min %s max %s\n'%(marker[0],al_[0],al_[1])
 			elif marker=='axis':
 				if match(r'axis\(',l):
	 				al  = s2gf.getarg1(l)
	 				al_ = s2gf.array_x(al)
	 				block = 'xaxis min '+al_[0]+' max '+al_[1]+'\n'
	 				block+= 'yaxis min '+al_[2]+' max '+al_[3]+'\n'
					curfig.axopt+=block
	 			else:
	 				# STUB STUB STUB STUB STUB
	 				# eg: axis ij, axis tight, ...
	 				pass
	 				# STUB STUB STUB STUB STUB
	 		# ---------
	 		# SET LINES
			elif marker=='set':
				# -------------
				# <- set GCA ->
				if match(r'set\(gca',l):
					args = s2gf.get_fargs(l)[1:] # False -> leave spaces
					while args:
						arg = s2gf.strip_d(args.pop(0).lower(),'\'').upper()
						if match(r'[XY]TICK$',arg):
							ticks = args.pop(0)
							#
							nc = ticks.count(':')
							if nc==1: # format a:b
								f,l = match(r'\[?\s*(.+)\s*:\s*(.+)\s*\]?',ticks).group(1,2),
								num = int(floor(float(l)-float(f))+1)
								curfig.axopt+='%saxis ftick %s dticks 1 nticks %i\n'%(arg[0],f,num)
							elif nc==2: # format a:b:c
								f,d,l = match(r'\[?\s*(.+?)\s*:\s*(.+?)\s*:\s*(.+?)\s*\]?',ticks).group(1,2,3)
								num   = int(floor((float(l)-float(f))/float(d)+1))
								curfig.axopt+='%saxis ftick %s dticks %s nticks %i\n'%(arg[0],f,d,num)
							else: # a or [a b c]
								ticks = s2gf.strip_d(ticks,r'\[|\]')
								ticks = sub(',',' ',ticks)
								curfig.axopt+='%splaces %s\n'%(arg[0],ticks)
						elif match(r'[XY]TICKLABEL$',arg):
							labels = s2gf.strip_d(args.pop(0),r'\[|\]')
							labels = sub(r'\'','"',labels)
							labels = sub(',',' ',labels)
							if no_tex:
								curfig.axopt+='%snames %s\n'%(arg[0],sub(r'\\','/',labels))
							else:
								curfig.axopt+='%snames %s\n'%(arg[0],sub('%','\%',labels))
						elif match(r'[XY]SCALE$',arg):
							scale = args.pop(0)
							curfig.axopt+='%saxis log\n'%arg[0]
						elif match(r'[XY]LIM$',arg):
							al  = args.pop(0)
			 				al_ = s2gf.array_x(al)
			 				curfig.axopt+='%saxis min %s max %s\n'%(arg[0],al_[0],al_[1])
			 			elif match(r'FONTSIZE',arg):
			 				fs  = args.pop(0)
			 				curfig.figoptfs = 'set hei %f'%(float(fs)/28.35/2.) # psp to cm
				# -------------
				# <- set GCF ->
				elif match(r'set\(gcf',l):
					# STUB STUB STUB STUB STUB
					pass
#	 		elif match(r'(#s2g:)',l):
#	 			s = match(r'(#s2g:)(.+)$',l).group(2)+'\n'
#				curfig.axopt+=s
	 		# ------------
	 		# LEGEND LINES
			elif marker=='legend':
				leg_stack = s2gf.get_fargs(l)
				leg_c     = 0
				while leg_stack:
					leg_i_str = s2gf.strip_d(leg_stack.pop(0),'\'')
					legistru  = leg_i_str.upper()
					if   legistru == 'LOCATION':
						leg_loc    = s2gf.strip_d(leg_stack.pop(0),'\'')
						curfig.legpos = 'pos %s'%s2gd.leg_dict.setdefault(leg_loc,'tr')
					elif legistru == 'BOXOFF':
						curfig.legopt+= ' nobox'
					elif legistru == 'OFFSET':
						leg_off    = s2gf.array_x(leg_stack.pop(0))
						curfig.legoff = ' offset '+' '.join(leg_off)
					else:
						if no_tex: leg_i_str = sub(r'\\','/',leg_i_str)
						#
						try:
							curfig.legend += 'text "%s" %s\n'%(leg_i_str,curfig.lstyles[leg_c])
							leg_c      += 1
						except IndexError, e:
							print '\nerror::S2G:: too many legends, did you forget a HOLD?\n'
			# ------------------------
	 		# RUN LINES (ext. scripts)
			elif marker==s2gd.csd['append']:
				scriptname = s2gf.strip_d(s2gf.getarg1(l),'\"')
				print 'Appending script <', scriptname, '>...'
				with open(scriptname,'r') as script:
					# prepend the script to stack of lines
					script_stack = script.readlines()+script_stack
		# if figure remains -> append it
		if curfig.plotcntr:
			figlist.append(curfig)
		#
		sf_tmp.write('\n%s\n'%s2gd.csd['exit'])

# = # = # = # = # = # = # = # = # = # = # = # = # = # = # = # = #
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# = # = # = # = # = # = # = # = # = # = # = # = # = # = # = # = #

###########################
# COMPILATION #############
###########################
# RUN SCRIPT
try:
	start = time()
	check_call('%s %s%s'%(s2gd.csd['caller'],s_tmp,fext),shell=True)
	delta = time()-start
	print 'Calling+executing script :: ',delta
except Exception, e:
	print e

# (GLE) compile figs
if not no_gleplot:
	start = time()
	if png_out:
		for f in figlist:
			f.compile(png_resol)
	else:
		for f in figlist:
			f.compile()
	delta = time()-start
	print 'Calling+executing GLE :: ',delta
else: # just copy gle files
	for f in figlist:
		f.writefile()

# CLEANUP
files = listdir('.')
for f in files:
	if f.startswith(s2gd.tind):
		if f.endswith('.pdf') or f.endswith('.png'):
			rename(f,f.strip(s2gd.tind))
		else:
			if not devmode: remove(f)