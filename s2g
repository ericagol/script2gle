#!/usr/bin/env python
# coding=utf-8
#
# GENERAL MODULES
from sys import argv
from subprocess import check_call
from re import search, sub, match
from os import remove, listdir, rename
from os.path import splitext, join
from numpy import floor
from time import time
# OWN MODULES
import glec
import s2gf
import s2gd

###########################
# USER ARGUMENTS ##########
###########################
devmode    = False # else-> cleanup temp folders
no_gleplot = False # does not compile GLE files
no_octave  = False # uses matlab instead of octave
no_tex     = True  # for quick graph 
png_out    = False # output in png instead of pdf
png_resol  = ''
if len(argv)>2:
	for arg in argv[2:]:
		if   bool(match(r'-dev',arg)):
			devmode = True
		elif bool(match(r'-noplot|-nogle',arg)):
			no_gleplot = True
		elif bool(match(r'-nooct|-noct',arg)):
			no_octave = True
		elif bool(match(r'-png',arg)):
			png_out   = True
			png_resol = '300'
		elif bool(match(r'-tex',arg)):
			no_tex = False
		else:
			print 'Ignoring unrecognized arg.: <'+arg+'>'
#
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
#
rname  	   = argv[1]
fname,fext = splitext(rname)    # full name with directory + file extension
fext 	   = fext.lower() 		
fname2 	   = fname.split('/')
fname2 	   = fname2[-1] 		# only name of file
gname  	   = fname+'.gle'
s_tmp      = '.__%s_script_tmp'%fname
#
figc    = 0  # number of figures
plotc   = 0  # number of plots for one figure
figs    = []
lstyles = [] # list of lstyles in curfig
flags   = {'holdon':False}
#
newfig = lambda figc: glec.gle('.__%s_plot%i'%(fname2,figc))
#
# script dictionary for the different languages
if fext   == '.jl':
	s2gd.csd = s2gd.script_dict_JL
elif fext == '.r':
	s2gd.csd = s2gd.script_dict_R
elif fext == '.m':
	s2gd.csd = s2gd.script_dict_M	
	if no_octave:
		s2gd.csd['caller'] = 'matlab -nodesktop -nosplash -noFigureWindows -r'
#
s2gd.ignored+=r'|^\s*%s'%s2gd.csd['comment']
s2gd.markers = r'|'.join([s2gd.markers,s2gd.csd['append']])
#
# == MAIN BLOCK =================
# create temp matlab file which
# outputs data file for each plot
with open(rname,'r') as sf_orig: 
	with open(s_tmp+fext,'w+') as sf_tmp:
		# script lines > stack of lines to process
		script_stack = sf_orig.readlines()
		while script_stack:
			# sanitize by gathering multiline expressions (EOL with '...')
			l,script_stack = s2gf.close_ellipsis(script_stack.pop(0),script_stack)
			# ignore lines like "home", "clear", comments,...
			if s2gf.match_start(s2gd.ignored,l): continue
			#
			marker = s2gf.match_start(s2gd.markers, l)
			if not marker:
				sf_tmp.write(l)
				continue
			else:
				marker = marker.group(1)
			# ---------------------
			# HOLD ON/OFF somewhere
			if marker=='hold':
				hon  = bool(search(r'hold(?!\s*off)',l))
				if hon:  l=sub(r'hold(?!\s*off)(.*;?\s*)','',l)
				hoff = bool(search(r'hold(\s+)off',l))
				if hoff: l=sub(r'hold(\s+)off(\s*;?\s*)','',l)
				flags['holdon'] = (hon or flags['holdon']) and (not hoff)
			# -----------
			# FIGURE LINE
			elif marker=='figure':
				figc 		   += 1
				if figc>1: figs.append(fig)
				fig,lstyles 	= newfig(figc), []
				fig.tex         = False if no_tex else True
				plotc 			= 0
				flags['holdon'] = False
				# -> write to temp matlab file
				sf_tmp.write('#'+l)
			# ---------
			# PLOT LINE
			elif match(r'(?:plot|semilog[xy]|stem|loglog|fill|fillbetween|hist|histogram|bar)$',marker):
				# ------------------
				# <- NEW GLE FIG? ->
				pre_figc = figc
				if not plotc:
					plotc,figc = 1,figc+(not figc)
				else:
					plotc = 1+plotc*flags['holdon']
					figc  = figc+1*(not flags['holdon'])
				# check if should generate new fig & append previous if any
				if figc>pre_figc:
					if figc>1: figs.append(fig)
					fig, lstyles = newfig(figc), []
					fig.tex = False if no_tex else True
				# ------------------
				# <- PLOT ACTIONS ->
				if marker in ['plot','semilogx','semilogy','stem','loglog']:
					# structify: extract code and options
					plt = s2gf.read_plot(l,figc,plotc)
					# -> write to temp script file
					sf_tmp.write(plt['script'])
					# -> write to temp gle file
					block = 'data ".__datplot%i_%i.dat" d%i\n'%(figc,plotc,plotc)
					block+= 'd%i'%plotc+									\
								' impulses '*bool(match(r'stem',marker))+ 	\
								plt['lstyle']+								\
								plt['lwidth']+								\
								plt['msize']+'\n'
					fig.plot+=block
					lstyles.append(plt['lstyle'])
					if match(r'semilog[xy]?',marker): fig.axopt+=marker[-1]+'axis log\n'
					elif match(r'loglog',marker): 	  fig.axopt+='xaxis log\nyaxis log\n'
				elif marker in ['fill','fillbetween']:
					if marker == 'fillbetween':
						fbargs = s2gf.get_fargs(l)
		 				l      = 'fill([%s,foo],[%s,fliplr(%s)],%s)'%(fbargs[0],fbargs[1],fbargs[2],s2gf.strip_d(str(fbargs[3:]),r'^\[|\]$'))
		 				l      = sub('"','',l)
		 			#
					fill = s2gf.read_fill(l,figc,plotc)
					# -> write to temp script file
					sf_tmp.write(fill['script'])
					# -> write to temp gle file
					block    = 'data ".__datfill%i_%i.dat" d%i\n'%(figc,plotc,plotc)
					block   += 'fill d%i,d%i color %s'%(plotc,plotc+1,fill['color'])
					fig.plot+= block
					fig.trsp = fig.trsp or fill['alpha']
				elif marker in ['hist','histogram']:
					hist = s2gf.read_hist(l,figc,plotc)
					# -> write to temp script file
					sf_tmp.write(hist['script'])
					# -> write to temp gle file
					# --- xtra
					block  = 'data ".__dathist%i_%i_side.dat" d%i\n'%(figc,plotc,plotc) # has to name: 1 col
					block += 'xmin_  = datayvalue(d%i,1)\n'%plotc
					block += 'xmax_  = datayvalue(d%i,2)\n'%plotc
					block += 'nbins_ = datayvalue(d%i,3)\n'%plotc
					# --- 
					block   += 'data ".__dathist%i_%i.dat" d%i\n'%(figc,plotc,plotc+1) # has to name: 1 col
					plotc   += 1
					block   += 'N_ = ndata(d%i)\n'%plotc
					block   += 'width_ = (xmax_-xmin_)/%s\n'%('nbins_')
					norm     = '1'
					if   hist['norm']=='probability':  norm = '1.0/N_'
					elif hist['norm']=='countdensity': norm = '1.0/width_'
					elif hist['norm']=='pdf':          norm = '1.0/(N_*width_)'
					block    += 'let d%i = hist d%i from xmin_ to xmax_ bins %s\n'%(plotc+1,plotc,'nbins_')
					block    += 'let d%i = d%i*%s\n'%(plotc+1,plotc+1,norm)
					block    += 'bar d%i color %s fill %s width %s\n'%(plotc+1,hist['edgecolor'],hist['facecolor'],'width_')
					fig.plot += block
					fig.trsp  = fig.trsp or hist['alpha']
					plotc    += 1
				elif marker == 'bar':
					bar = s2gf.read_bar(l,figc,plotc)
					# -> write to temp script file
					sf_tmp.write(bar['script'])
					# -> write to temp gle file
					# --- xtra
					block  = 'data ".__datbar%i_%i_side.dat"\n'%(figc,plotc,plotc)
					block += 'ncols_ = datayvalue(d%i,1)\n'%(plotc)
					block += 'bstr_$ = "d%i"\n'%(plotc+1)
					block += 'for k=1 to ncols_-1, bstr_$=bstr_$+",d"+num$(k),next k\n'
					# # ---
					# block  = 'data ".__datbar%i_%i.dat" bstr_$ \n'%(figc,plotc)
					# block += 'bar d%i color %s fill %s width %f\n'%(plotc+1,bar['edgecolor'],bar['facecolor'],bar['width'])
					#
					xaxisopt  = ''
					if not bar['flticks']:
						xaxisopt+='nofirst nolast '
					if bar['xdticks']:
						xaxisopt+='dticks %s '%bar['xdticks']
					#
					if xaxisopt:
						block += 'xaxis '+xaxisopt+'\n'
					fig.plot  += block
					fig.trsp   = fig.trsp or bar['alpha']
					plotc     += 1
 			# -------------------------
 			# AXIS LINES (pass in temp)
 			# (atm, ignore fontsize)
 			elif match(r'(?:[xy]label|title)$',marker):
 				al = s2gf.getarg1(l)
 				marker = '' if (marker=='title') else marker[0]
 				if no_tex:
 					fig.axopt+=marker+'title "%s"\n'%sub(r'\\','/',al)
 				else:
 					fig.axopt+=marker+'title "\\tex{%s}"\n'%sub('%','\%',al)
			elif match(r'(?:[xy]lim)$',marker):
 				al  = s2gf.getarg1(l)
 				al_ = s2gf.array_x(al)
 				fig.axopt+=marker[0]+'axis min '+al_[0]+' max '+al_[1]+'\n'
 			elif marker=='axis':
 				if match(r'axis\(',l):
	 				al  = s2gf.getarg1(l)
	 				al_ = s2gf.array_x(al)
	 				block = 'xaxis min '+al_[0]+' max '+al_[1]+'\n'
	 				block+= 'yaxis min '+al_[2]+' max '+al_[3]+'\n'
	 				fig.axopt+=block
	 			else:
	 				# STUB STUB STUB STUB STUB
	 				# eg: axis ij, axis tight, ...
	 				pass
	 				# STUB STUB STUB STUB STUB
	 		# ---------
	 		# SET LINES
			elif marker=='set':
				# -------------
				# <- set GCA ->
				if match(r'set\(gca',l):
					args = s2gf.get_fargs(l)[1:] # False -> leave spaces
					while args:
						arg = s2gf.strip_d(args.pop(0).lower(),'\'').upper()
						if match(r'[XY]TICK$',arg):
							ticks = args.pop(0)
							#
							nc = ticks.count(':')
							if nc==1: # format a:b
								f,l = match(r'\[?\s*(.+)\s*:\s*(.+)\s*\]?',ticks).group(1,2),
								num = int(floor(float(l)-float(f))+1)
								fig.axopt+='%saxis ftick %s dticks 1 nticks %i\n'%(arg[0],f,num)
							elif nc==2: # format a:b:c
								f,d,l = match(r'\[?\s*(.+?)\s*:\s*(.+?)\s*:\s*(.+?)\s*\]?',ticks).group(1,2,3)
								num   = int(floor((float(l)-float(f))/float(d)+1))
								fig.axopt+='%saxis ftick %s dticks %s nticks %i\n'%(arg[0],f,d,num)
							else: # a or [a b c]
								ticks = s2gf.strip_d(ticks,r'\[|\]')
								ticks = sub(',',' ',ticks)
								fig.axopt+='%splaces %s\n'%(arg[0],ticks)
						elif match(r'[XY]TICKLABEL$',arg):
							labels = s2gf.strip_d(args.pop(0),r'\[|\]')
							labels = sub(r'\'','"',labels)
							labels = sub(',',' ',labels)
							if no_tex:
								fig.axopt+='%snames %s\n'%(arg[0],sub(r'\\','/',labels))
							else:
			 					fig.axopt+='%snames %s\n'%(arg[0],sub('%','\%',labels))
						elif match(r'[XY]SCALE$',arg):
							scale = args.pop(0)
							fig.axopt+='%saxis log\n'%arg[0]
						elif match(r'[XY]LIM$',arg):
							al  = args.pop(0)
			 				al_ = s2gf.array_x(al)
			 				fig.axopt+='%saxis min %s max %s\n'%(arg[0],al_[0],al_[1])
			 			elif match(r'FONTSIZE',arg):
			 				fs  = args.pop(0)
			 				fig.figoptfs = 'set hei %f'%(float(fs)/28.35/2.) # psp to cm
				# -------------
				# <- set GCF ->
				elif match(r'set\(gcf',l):
					# STUB STUB STUB STUB STUB
					pass
	 		elif match(r'(#j2g:)',l):
	 			s = match(r'(#j2g:)(.+)$',l).group(2)+'\n'
	 			fig.axopt+=s
	 		# ------------
	 		# LEGEND LINES
			elif marker=='legend':
				leg_stack = s2gf.get_fargs(l)
				leg_c     = 0
				while leg_stack:
					leg_i_str = s2gf.strip_d(leg_stack.pop(0),'\'')
					legistru  = leg_i_str.upper()
					if   legistru == 'LOCATION':
						leg_loc    = s2gf.strip_d(leg_stack.pop(0),'\'')
						fig.legpos = 'pos %s'%s2gd.leg_dict.setdefault(leg_loc,'tr')
					elif legistru == 'BOXOFF':
						fig.legopt+= ' nobox'
					elif legistru == 'OFFSET':
						leg_off    = s2gf.array_x(leg_stack.pop(0))
						fig.legoff = ' offset '+' '.join(leg_off)
					else:
						if no_tex: leg_i_str = sub(r'\\','/',leg_i_str)
						#
						try:
							fig.legend += 'text "%s" %s\n'%(leg_i_str,lstyles[leg_c])
							leg_c      += 1
						except IndexError, e:
							print '\nerror::S2G:: too many legends, did you forget a HOLD?\n'
			# ------------------------
	 		# RUN LINES (ext. scripts)
			elif marker==s2gd.csd['append']:
				scriptname = s2gf.strip_d(s2gf.getarg1(l),'\"')
				print scriptname
				print 'Appending script <', scriptname, '>...'
				with open(scriptname,'r') as script:
					# prepend the script to stack of lines
					script_stack = script.readlines()+script_stack
		# if figure remains -> append it
		if figc>len(figs): figs.append(fig)
		sf_tmp.write('\n%s\n'%s2gd.csd['exit'])

# = # = # = # = # = # = # = # = # = # = # = # = # = # = # = # = #
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# = # = # = # = # = # = # = # = # = # = # = # = # = # = # = # = #

###########################
# COMPILATION #############
###########################
# RUN SCRIPT
try:
	start = time()
	check_call('%s %s%s'%(s2gd.csd['caller'],s_tmp,fext),shell=True)
	delta = time()-start
	print 'Calling+executing script :: ',delta
except Exception, e:
	print e

# (GLE) compile figs
if not no_gleplot:
	start = time()
	if png_out:
		for f in figs:
			f.compile(png_resol)
	else:
		for f in figs:
			f.compile() # pdf output
	delta = time()-start
	print 'Calling+executing GLE :: ',delta
else: # just copy gle files
	for f in figs: f.writefile()

# CLEANUP
files = listdir('.')
for f in files:
	if f.startswith('.__'):
		if f.endswith('.pdf') or f.endswith('.png'):
			rename(f,f.strip('.__'))
		else:
			if not devmode: remove(f)