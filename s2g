#!/usr/bin/env python
# coding=utf-8
#
# GENERAL MODULES
from sys import argv, path
from subprocess import check_call
from re import search, sub, match
from shutil import rmtree, copy
from glob import iglob
from os.path import splitext, join, isfile
from numpy import floor
from time import time
# OWN MODULES
import glec
import s2gf
from s2gd import *

###########################
# USER ARGUMENTS ##########
###########################
devmode    = False # else-> cleanup temp folders
no_gleplot = False # does not compile GLE files
no_octave  = False # uses matlab instead of octave
no_tex     = False # for quick graph 
png_out    = False # output in png instead of pdf
png_resol  = ''
if len(argv)>2:
	for arg in argv[2:]:
		if   bool(match(r'-dev',arg)):
			devmode = True
		elif bool(match(r'-noplot|-nogle',arg)):
			no_gleplot = True
		elif bool(match(r'-nooct|-noct',arg)):
			no_octave = True
		elif bool(match(r'-png',arg)):
			png_out   = True
			png_resol = '300'
		elif bool(match(r'-notex|-draft',arg)):
			no_tex = True
		else:
			print 'Ignoring unrecognized arg.: <'+arg+'>'
#
# ------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------
#
rname  	   = argv[1]
fname,fext = splitext(rname)    # full name with directory + file extension
fname2 	   = fname.split('/')
fname2 	   = fname2[-1] 		# only name of file
gname  	   = fname+'.gle'
#
t_dir = '_%s_tmpdir/'%fname
s_tmp = t_dir+'script_tmp'
# create folder
check_call('mkdir -p '+t_dir,shell=True)
#
figc    = 0  # number of figures
plotc   = 0  # number of plots for one figure
figs    = []
lstyles = [] # list of lstyles in curfig
flags   = {'holdon':False}
#
newfig   = lambda figc: glec.gle('%s%s_plot%i'%(t_dir,fname2,figc))
getarg1  = lambda l,re: s2gf.strip_d(s2gf.get_fargs(l,re)[0],'\'')
#
#
# script dictionary for the different languages
# >> JULIA
if fext == '.jl':
	script_dict_JL = {
		'append'	: 'include',
		'writevar'	: 'writecsv(\"%s\",%s)',
		'vec'		: '[:]',
		'EOL'		: '',
		'cbind' 	: '[%s %s]',
		'span' 		: '1:prod(size(%s))'
	}
	caller = 'julia'
# >> MATLAB/OCTAVE
elif fext == '.m':
	script_dict = {
		'append'	: 'run',
		'writevar'	: 'save(\'-ascii\',\'%s\',\'%s\')',
		'vec'		: '(:)',
		'EOL'		: ';',
		'cbind'		: '[%s %s]',
		'span'		: '1:prod(size(%s))'
	}
	if no_octave:
		caller = 'matlab -nodesktop -nosplash -noFigureWindows -r'
	else:
		caller = 'octave -q'
markers = r'|'.join([markers,script_dict['append']])
#
# == MAIN BLOCK =================
# create temp matlab file which
# outputs data file for each plot
with open(rname,'r') as sf_orig:
	with open(s_tmp+fext,'w+') as sf_tmp:
		# script lines > stack of lines to process
		stack = sf_orig.readlines()
		while stack:
			l = stack.pop(0)
			# lines to ignore (and write as blank) if they appear
			if  s2gf.match_start(ignored,l): continue
			#
			marker = s2gf.match_start(markers, l)
			if not marker:
				sf_tmp.write(l)
				continue
			else:
				marker = marker.group(1)
			# ---------------------
			# HOLD ON/OFF somewhere
			if marker=='hold':
				hon  = bool(search(r'hold(?!\s*off)',l))
				if hon:  l=sub(r'hold(?!\s*off)(.*;?\s*)','',l)
				hoff = bool(search(r'hold(\s+)off',l))
				if hoff: l=sub(r'hold(\s+)off(\s*;?\s*)','',l)
				flags['holdon'] = (hon or flags['holdon']) and (not hoff)
			# -----------
			# FIGURE LINE
			elif marker=='figure':
				figc 		   += 1
				if figc>1: figs.append(fig)
				fig,lstyles 	= newfig(figc), []
				fig.tex         = False if no_tex else True
				plotc 			= 0
				flags['holdon'] = False
				# -> write to temp matlab file
				sf_tmp.write('#'+l)
			# ---------
			# PLOT LINE
			elif match(r'(?:plot|semilog[xy]|stem|loglog|fill|fillbetween|bar)$',marker):
				# ------------------
				# <- NEW GLE FIG? ->
				pre_figc = figc
				if not plotc:
					plotc,figc = 1,figc+(not figc)
				else:
					plotc = 1+plotc*flags['holdon']
					figc  = figc+1*(not flags['holdon'])
				# check if should generate new fig & append previous if any
				if figc>pre_figc:
					if figc>1: figs.append(fig)
					fig, lstyles = newfig(figc), []
					fig.tex = False if no_tex else True
				# ------------------
				# <- PLOT ACTIONS ->
				if marker in ['plot','semilogx','semilogy','stem','loglog']:
					# structify: extract code and options
					plt = s2gf.read_plot(l,t_dir,figc,plotc,script_dict,col_dict)
					# -> write to temp script file
					sf_tmp.write(plt['script'])
					# -> write to temp gle file
					block = 'data "datplot%i_%i.dat" d%i=c1,c2\n'%(figc,plotc,plotc)
					block+= 'd%i'%plotc+									\
								' impulses '*bool(match(r'stem',marker))+ 	\
								plt['lstyle']+								\
								plt['lwidth']+								\
								plt['msize']+'\n'
					fig.plot+=block
					lstyles.append(plt['lstyle'])
					if match(r'semilog[xy]?',marker): fig.axopt+=marker[-1]+'axis log\n'
					elif match(r'loglog',marker): 	  fig.axopt+='xaxis log\nyaxis log\n'
				elif marker in ['fill','fillbetween']:
					if marker == 'fillbetween':
						fbargs = s2gf.get_fargs(l,False)
		 				l      = 'fill([%s,foo],[%s,fliplr(%s)],%s)'%(fbargs[0],fbargs[1],fbargs[2],s2gf.strip_d(str(fbargs[3:]),r'^\[|\]$'))
		 				l      = sub('"','',l)
		 			#
					fill = s2gf.read_fill(l,t_dir,figc,plotc,script_dict,col_dict,svg2rgb_dict)
					# -> write to temp script file
					sf_tmp.write(fill['script'])
					# -> write to temp gle file
					block    = 'data "datfill%i_%i.dat" d%i=c1,c2 d%i=c1,c3\n'%(figc,plotc,plotc,plotc+1)
					block   += 'fill d%i,d%i color %s'%(plotc,plotc+1,fill['color'])
					fig.plot+= block
					fig.trsp = fill['alpha']
				elif marker == 'bar':
					continue
 			# -------------------------
 			# AXIS LINES (pass in temp)
 			# (atm, ignore fontsize)
 			elif match(r'(?:[xy]label|title)$',marker):
 				al = getarg1(l,False)
 				marker = '' if (marker=='title') else marker[0]
 				if no_tex:
 					fig.axopt+=marker+'title "%s"\n'%sub(r'\\','/',al)
 				else:
 					fig.axopt+=marker+'title "\\tex{%s}"\n'%sub('%','\%',al)
			elif match(r'(?:[xy]lim)$',marker):
 				al  = getarg1(l,False)
 				al_ = s2gf.array_x(al)
 				fig.axopt+=marker[0]+'axis min '+al_[0]+' max '+al_[1]+'\n'
 			elif marker=='axis':
 				if match(r'axis\(',l):
	 				al  = getarg1(l,False)
	 				al_ = s2gf.array_x(al)
	 				block = 'xaxis min '+al_[0]+' max '+al_[1]+'\n'
	 				block+= 'yaxis min '+al_[2]+' max '+al_[3]+'\n'
	 				fig.axopt+=block
	 			else:
	 				# STUB STUB STUB STUB STUB
	 				# eg: axis ij, axis tight, ...
	 				pass
	 				# STUB STUB STUB STUB STUB
	 		# ---------
	 		# SET LINES
			elif marker=='set':
				# -------------
				# <- set GCA ->
				if match(r'set\(gca',l):
					args = s2gf.get_fargs(l,False)[1:] # False -> leave spaces
					while args:
						arg = s2gf.strip_d(args.pop(0).lower(),'\'').upper()
						if match(r'[XY]TICK$',arg):
							ticks = args.pop(0)
							#
							nc = ticks.count(':')
							if nc==1: # format a:b
								f,l = match(r'\[?\s*(.+)\s*:\s*(.+)\s*\]?',ticks).group(1,2),
								num = int(floor(float(l)-float(f))+1)
								fig.axopt+='%saxis ftick %s dticks 1 nticks %i\n'%(arg[0],f,num)
							elif nc==2: # format a:b:c
								f,d,l = match(r'\[?\s*(.+)\s*:\s*(.+)\s*:\s*(.+)\s*\]?',ticks).group(1,2,3),
								num   = int(floor((float(l)-float(f))/float(d)+1))
								fig.axopt+='%saxis ftick %s dticks %s nticks %i\n'%(arg[0],f,d,num)
							else: # a or [a b c]
								ticks = s2gf.strip_d(ticks,r'\[|\]')
								ticks = sub(',',' ',ticks)
								fig.axopt+='%splaces %s\n'%(arg[0],ticks)
						elif match(r'[XY]TICKLABEL$',arg):
							labels = s2gf.strip_d(args.pop(0),r'\[|\]')
							labels = sub(r'\'','"',labels)
							labels = sub(',',' ',labels)
							if no_tex:
								fig.axopt+='%snames %s\n'%(arg[0],sub(r'\\','/',labels))
							else:
			 					fig.axopt+='%snames %s\n'%(arg[0],sub('%','\%',labels))
						elif match(r'[XY]SCALE$',arg):
							scale = args.pop(0)
							fig.axopt+='%saxis log\n'%arg[0]
						elif match(r'[XY]LIM$',arg):
							al  = args.pop(0)
			 				al_ = s2gf.array_x(al)
			 				fig.axopt+='%saxis min %s max %s\n'%(arg[0],al_[0],al_[1])
			 			elif match(r'FONTSIZE',arg):
			 				fs  = args.pop(0)
			 				fig.figoptfs = 'set hei %f'%(float(fs)/28.35/2.) # psp to cm
				# -------------
				# <- set GCF ->
				elif match(r'set\(gcf',l):
					# STUB STUB STUB STUB STUB
					pass
	 		elif match(r'(#j2g:)',l):
	 			s = match(r'(#j2g:)(.+)$',l).group(2)+'\n'
	 			fig.axopt+=s
	 		# ------------
	 		# LEGEND LINES
			elif marker=='legend':
				leg_stack = s2gf.get_fargs(l,False)
				leg_c     = 0
				while leg_stack:
					leg_i_str = s2gf.strip_d(leg_stack.pop(0),'\'')
					legistru  = leg_i_str.upper()
					if   legistru == 'LOCATION':
						leg_loc    = s2gf.strip_d(leg_stack.pop(0),'\'')
						fig.legpos = 'pos %s'%leg_dict.setdefault(leg_loc,'tr')
					elif legistru == 'BOXOFF':
						fig.legopt+= ' nobox'
					elif legistru == 'OFFSET':
						leg_off    = s2gf.array_x(leg_stack.pop(0))
						fig.legoff = ' offset '+' '.join(leg_off)
					else:
						if no_tex: leg_i_str = sub(r'\\','/',leg_i_str)
						#
						try:
							fig.legend += 'text "%s" %s\n'%(leg_i_str,lstyles[leg_c])
							leg_c      += 1
						except IndexError, e:
							print '\nerror::S2G:: too many legends, did you forget a HOLD?\n'
			# ------------------------
	 		# RUN LINES (ext. scripts)
			elif marker==script_dict['append']:
				scriptname = s2gf.strip_d(s2gf.get_fargs(l)[0],'\"')
				print 'Appending script <', scriptname, '>...'
				with open(scriptname,'r') as script:
					# prepend the script to stack of lines
					stack = script.readlines()+stack
		# if figure remains -> append it
		if figc>len(figs): figs.append(fig)
		sf_tmp.write('\nexit()\n')

# = # = # = # = # = # = # = # = # = # = # = # = # = # = # = # = #
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# = # = # = # = # = # = # = # = # = # = # = # = # = # = # = # = #

###########################
# COMPILATION #############
###########################
# Short side functions
def copy_xt(ext):
	global t_dir
	files = iglob(join(t_dir,ext))
	for file in files:
		if isfile(file): copy(file,t_dir+'/..')

# RUN SCRIPT
try:
	start = time()
	check_call('%s %s%s'%(caller,s_tmp,fext),shell=True)
	delta = time()-start
	print 'Calling+executing script :: ',delta
except Exception, e:
	print e

# (GLE) compile figs
if not no_gleplot:
	start = time()
	if png_out:
		for f in figs:
			f.compile(png_resol)
	else:
		for f in figs:
			f.compile() # pdf output
	delta = time()-start
	print 'Calling+executing GLE :: ',delta
else: # just copy gle files
	for f in figs: f.writefile()
	copy_xt("*.gle")

# CLEANUP
if not devmode:
	if png_out:
		copy_xt("*.png")
	else:
		copy_xt("*.pdf")
	rmtree(t_dir)
